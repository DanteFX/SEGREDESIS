

## Descripción
In RSA d is a lot bigger than e, why don't we use d to encrypt instead of e? Connect with `nc jupiter.challenges.picoctf.org 18243`.

## Solución
``` python
┌─[dantefx@dantefx-Inspiron5481]─[~/Descargas/RsaCtfTool-master]
└──╼ $python3
Python 3.9.2 (default, Feb 28 2021, 17:03:44) 
[GCC 10.2.1 20210110] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> c=22853337230104341265916547203556128922581699881756622271684304153357491800385378912078980869216510504665690518557218588169754681784792797092321026646730637952082415209852715769289639939739131706185888294479489808674072512416143619518826429849882841575740531981628176437623349050444995356652749763798652828628
>>> n=104510802313098602172737389256746754917054149630353527534914130697641195674183410195952653440322067767371029464929969531138923136347783653770216469620444397898648347324857048897998184685891320401741219636577857674079162618832082237624217550982610498788211399930786876558280559776657307812737113958005560696711
>>> d=52967427542145201507049031602954719693760068052736506356289925555367995396768267843486387598155202113206719008768313135736749194711256756640946946586555075356312743413516375400135077533615825696526149608572697871119977501402218460926306273864672955967825596070528119546335768247571726936819753709935857326713
>>> e=65537
>>> m = pow(c, d, n)
>>> from Crypto.Util.number import long_to_bytes
>>> long_to_bytes(m)
b"s\x173c\xf4\xb7'\xdd\xaaO\x06@\xe0\x83\x02u\x00\xbc\x96#9a\xfb\xe7\xb6}e\xcf\xefA\xb3T\xbe\xca\xaa\x10~\x92\x91\xab\xfco\xbd\xa0\xcb\xefG\xaaR\xbe&\x93\x16\xec\xb5\x02p#\xb1\x8d\x00@\xf8[\xd7\xef\x85\xcfl\r\xc9\x13F\x17\xb9\xeb\xfc\xcc\x9bGa\xaf4\x06\xfd\xb4\x01\xff\x94_\xcb[\x02\xaf!#:\xeb8]q\x89\x0eb\x8f\t\xbfX\x13:_\x15&\xe3\x92\x97\xc4Kw\x92\x9b\x85\xb2\xc3\x12\x9c\xb6\xb3"
>>> m = pow(c, e, n)
>>> long_to_bytes(m)
b'picoCTF{bad_1d3a5_4783252}'

```
picoCTF{n33d_a_lArg3r_e_606ce004}